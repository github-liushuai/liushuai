计算机工作模式图
                  内存
                   ↑
                   |内存总线 
                   ↓
CPU <-系统总线-> I/O桥芯片 <----I/O总线---->
                          ↑   ↑   ↑   ↑
                          |   |   |   |
                          ↓   ↓   ↓   ↓
                         USB 硬盘 网卡 显卡
                         
CPU又由三部分组成
  控制单元：获取指令然后指导计算单元计算去数据单元里面拿数据计算
  数据单元：包括CPU内部的缓存和寄存器组
  计算单元：只做计算
  
                         
CPU和其他设备连续，需要依靠总线
  地址总线：地址数据，决定了寻址范围
  数据总线：真正的数据，决定了每次可以拿到多少数据
  
8086处理器
每个进程都有四个16位的段寄存器来指向其代码段和数据段，分别是
  CS：代码段寄存器
  DS：数据段寄存器
  SS：栈寄存器
  ES：附加段寄存器
但是地址总线是20位的，所以使用的方法是 起始地址*16+偏移量 就可以得到20位的数据地址了

32位处理器
地址总线由之前的16位扩展为32位，这跟之前的20位地址总线不能完全兼容，所以对这4个段寄存器重新设计了，并新增了段描述符缓存器（这里面存段是之前放在CS、DS等里面等其实地址），而CS、DS保存的是在段缓存器中的哪一项
这样，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址
这样就不兼容了，怎么处理呢？
  我们将之前的模式称为实模式，系统刚启动时是处于实模式的（为了向下兼容），这样就能跟之前兼容了
  后一种称为保护模式，我们可以根据需要切换到保护模式，不能无缝兼容但是可以通过切换模式兼容
实模式和保护模式的根本区别是 进程内存受保护与否；保护模式比实模式提高了系统的多道任务和系统的稳定性，例如内存的保护、分页机制和硬件虚拟存储的支持

留个问题后面再回来看：保护模式下是如何实现内存保护的，目前只知道段寄存器最后两位是特权级表示访问权限，但是这个权限又是谁赋予的？描述符表中对应地址段的权限又是怎么来的？

