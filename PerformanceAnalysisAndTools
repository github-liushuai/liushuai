#linux性能分析工具
1）vmstat
对系统级的整体情况进行统计，不足之处是无法对某个进程进行深入分析
用法：vmstat interval [times]，即每隔interval秒采样一次，共采样times次，如果省略times，则一直采集数据到用户手动停止
#vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 46839104 2596188 145670048    0    0    47    91    0    0  0  1 99  0  0
 0  0      0 46838628 2596196 145670064    0    0     0    30 1028 1659  0  0 100  0  0
 0  0      0 46838992 2596204 145670064    0    0     0    20 1050 1713  0  0 100  0  0
 0  0      0 46839092 2596212 145670064    0    0     0    16 1288 1991  0  0 100  0  0
 ...
 
 第一行的值是显示了自系统启动以来的平均值，第二行开始展示现在正在发生的情况，接下来的行会显示每5秒的间隔内发生了什么，每一列的含义在头部，如下所示：
 procs：
 r -- 多少进程正在等待cpu -- 展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈
 b -- 多少进程正在不可中断的休眠（通常意味着它们在等待IO ，例如磁盘，网络，用户输入，等等）
 
 memory：
 swpd -- 正在使用虚拟的内存大小，单位k
 free -- 空闲内存大小
 buff -- 已用的buff大小，对块设备的读写进行缓冲
 cache -- 已用的cache大小，文件系统的cache
 inact -- 非活跃内存大小，即被标明可回收的内存，区别于free和active（当使用-a选项时显示）
 active -- 活跃的内存大小（当使用-a选项时显示）
 
 swap：
 si -- 每秒从交换区写入内存的大小（单位：kb/s） -- 如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉
 so -- 每秒从内存写到交换区的大小 -- 同上
 
 io：
 bi -- 每秒读取的块数（读磁盘）
 bo -- 每秒写入的块数（写磁盘）
 
 system：这两个值越大，会看到由内核消耗的cpu时间会越多
 in -- 每秒中断数，包括时钟中断
 cs -- 每秒上下文切换数
 
 cpu:
 us -- 用户进程执行消耗cpu时间(user time) -- us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了
 sy -- 系统进程消耗cpu时间(system time) -- sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因
 id -- 空闲时间(包括IO等待时间)
 wa -- 等待IO时间 -- Wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈
 st -- 虚拟机偷取时间 -- 是专门对虚拟机来说的，一台物理是可以虚拟化出几台虚拟机的，在其中一台虚拟机上用top查看发现st不为0，就说明本来有这么多个cpu时间是安排给我这个虚拟机的，但是由于某种虚拟技术，把这个cpu时间分配给了其他的虚拟机了

2）iostat
对系统级的I/O情况进行分析，不足之处是无法对某个进程进行深入分析
用法：iostat -dx interval [times]，默认情况下，它显示了与vmstat 相同的CPU使用信息，使用dx参数可仅输出I/O相关的数据，每隔interval秒采样一次，共采样times次
#iostat -dx 3
Linux 3.10.0-327.ali2018.alios7.x86_64 (OceanBase166085097.sqa.eu95) 	01/19/2020 	_x86_64_	(24 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.01   186.87   19.36   16.22   723.09   967.64    95.03     0.03    0.83    0.14    1.65   1.07   3.82
sdb               0.00   284.49    4.07    9.25   385.71  1175.23   234.50     0.08    6.20    0.13    8.87   4.32   5.75
nb0               0.00     0.00    0.00    0.00     0.00     0.00     8.37     0.00    0.38    0.35    3.57   0.03   0.00

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.00     5.67    0.00    7.67     0.00    56.00    14.61     0.00    0.09    0.00    0.09   0.09   0.07
sdb               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00
nb0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.00     0.00    0.00    3.00     0.00    14.67     9.78     0.00    0.00    0.00    0.00   0.00   0.00
sdb               0.00     3.67    0.00    0.67     0.00    17.33    52.00     0.00    0.00    0.00    0.00   0.00   0.00
nb0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00
...

为了看懂Linux的磁盘IO指标，先了解一些常见的缩写习惯：
rq -- request
r -- read
w -- write
qu -- queue（队列）
sz -- size
a -- average（平均）
tm -- time
svc -- service

下面讲解具体项的含义（第一次采样信息与单独执行iostat的效果一样，为从系统开机到当前执行时刻的统计信息）：
rrqm/s 和 wrqm/s -- 每秒合并的读和写请求，"合并的"意味着文件系统会对读取同块(block)的请求进行合并
r/s 和 w/s -- 每秒发送到设备的读和写请求数
rkB/s 和 wkB/s -- 每秒 读/写 数据量(kB为单位)
avgrq-sz -- 平均每次IO操作的数据量(扇区数为单位)
avgqu-sz -- 平均等待处理的IO请求队列长度
await -- 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)
svctm -- 平均每次IO请求的处理时间(毫秒为单位)
%util -- 采用周期内用于IO操作的时间比率，即IO队列非空的时间比率

IO瓶颈的症状： 1.%util 很高  2.await 远大于svctm  3.avgqu-sz 比较大

结合vmstat和iostat两个命令，可以查看到以下类型机器的输出分别有以下特点
cpu 密集型机器：
vmstat 输出通常在us列（用户进程消耗cpu时间）会有一个很高的值，也可能在sy列（系统进程消耗cpu时间）有很高的值，超过20%就足以令人不安了，在大部分情况下，也会有进程队列排队时间（在r列报告的）
iostat 的输出（剔除显示启动以来平均值的第一行），可以发现磁盘利用率低于50%

IO 密集型机器：
在IO密集型工作负载下，CPU花费大量时间在等待IO请求完成。这意味着vmstat 会显示很多处理器在非中断休眠(b列)状态，并且在wa（等待IO时间）这一列的值很高
iostat 输出显示硬盘一直很忙
只要有足够的缓冲来服务写请求，即使机器正在做大量的写操作，也可能可以满足，但是却通常意味着硬盘可能会无法满足读请求，因为写有缓冲而读没有

发生内存交换的机器：
swpd 列可能有一个很高的值，也可能不高，但是可以看到si 和 so 列有很高的值

空闲的机器：
idle列显示CPU是接近100%的空闲

3）dstat
dstat 显示了cpu使用情况，磁盘io 情况，网络发包情况和换页情况
dstat使用时，直接输入命令即可，不用任何参数，也可以通过指定参数来显示更加详细的信息
#dstat
You did not select any stats, using -cdngy by default.
----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw
  0   1  99   0   0   0|1108k 2142k|   0     0 |   0     0 |2564  3840
  0   0 100   0   0   0|   0    16k|1442B   12k|   0     0 |1358  2120
  0   0 100   0   0   0|   0     0 | 940B 7750B|   0     0 |1504  2432
  0   0 100   0   0   0|   0     0 | 652B 1166B|   0     0 |1069  1765
  0   0 100   0   0   0|   0    16k| 922B 6756B|   0     0 |1498  2014
  0   1  99   0   0   0|   0    92k|1456B   23k|   0     0 |2481  3724
  0   0 100   0   0   0|   0     0 |2160B   27k|   0     0 |1482  2268

#dstat -cdlmnpsy
----total-cpu-usage---- -dsk/total- ---load-avg--- ------memory-usage----- -net/total- ---procs--- ----swap--- ---system--
usr sys idl wai hiq siq| read  writ| 1m   5m  15m | used  buff  cach  free| recv  send|run blk new| used  free| int   csw
  0   1  99   0   0   0|1108k 2142k|   0 0.14 0.30|10.6G 2501M  168G 8030M|   0     0 |  0   0 9.3|   0     0 |2564  3840
  0   0 100   0   0   0|   0    88k|   0 0.14 0.30|10.6G 2501M  168G 8026M|1594B   23k|  0   0 1.0|   0     0 |1345  2105
  0   0 100   0   0   0|   0     0 |   0 0.14 0.30|10.6G 2501M  168G 8025M| 772B 7232B|  0   0  13|   0     0 |1420  2192
  0   0 100   0   0   0|   0  4096B|   0 0.14 0.30|10.6G 2501M  168G 8026M| 472B  900B|  0   0   0|   0     0 | 951  1605
  0   0 100   0   0   0|   0    24k|   0 0.14 0.30|10.6G 2501M  168G 8026M| 412B  908B|  0   0 1.0|   0     0 |1076  1732
  0   0 100   0   0   0|   0     0 |   0 0.14 0.29|10.6G 2501M  168G 8026M| 896B 1636B|  0   0 1.0|   0     0 | 919  1519
  0   0 100   0   0   0|   0     0 |   0 0.14 0.29|10.6G 2501M  168G 8026M| 406B 1068B|  0   0 1.0|   0     0 | 982  1572
  
CPU状态：CPU的使用率，显示了用户占比，系统占比、空闲占比、等待占比、硬中断和软中断情况
磁盘统计：磁盘的读写，分别显示磁盘的读、写总数。
网络统计：网络设备发送和接受的数据，分别显示的网络收、发数据总数。
分页统计：系统的分页活动，分别显示换入（in）和换出（out），一个较大的分页表明系统正在使用大量的交换空间，理想情况下page in（换入）和page out（换出）的值是0
系统统计：统计中断（int）和上下文切换（csw）

4）iotop
通过iostat和dstat我们可以知道系统的当前IO负载，但是要知道IO负载具体是由哪个进程产生的可以通过iotop命令
用法与top相似，也可以使用非交互式的方式使用：iotop -bod interval

5）pidstat
进程粒度的状态信息
用法1：pidstat -d interval 与iotop -bod interval返回相似
用法2：pidstat -u interval 统计CPU使用信息
用法3：pidstat -r interval 统计内存信息

6）top
#top
top - 15:26:35 up 165 days, 18:05, 11 users,  load average: 0.00, 0.03, 0.12
Tasks: 660 total,   1 running, 659 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 19787744+total,  8208520 free,  2842900 used, 18682601+buff/cache
KiB Swap:        0 total,        0 free,        0 used. 18633395+avail Mem
   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  7433 root      20   0  391248   9272   2204 S   0.7  0.0 984:37.36 alisentry_cli
 33813 root      39  19 4398380 251604   5284 S   0.7  0.1   2169:56 argusagent
 75360 root      20   0  168748   2944   1612 R   0.7  0.0   0:00.51 top
 41756 root      20   0 3777592  63708  11704 S   0.3  0.0 250:53.78 dockerd
 55178 root      20   0 2555140  16544   2788 S   0.3  0.0  32:58.34 staragentd
 汇总区域显示了五个方面的系统性能信息： 
 1. 负载：时间，登录用户数，系统平均负载 
 2. 进程：运行，睡眠，停止，僵尸 
 3. CPU ：用户态，核心态，NICE，空闲，等待IO，中断等 
 4. 内存：总量，已用，空闲（系统角度），缓冲，缓存 
 5. 交换分区：总量，已用，空闲
 
 任务区域默认显示：
 进程ID，有效用户，进程优先级，NICE值，进程使用的虚拟内存、物理内存、共享内存，进程状态，CPU 占用率，内存占用率，累计CPU时间，进程命令行信息

7）mpstat
用来统计多核处理器中，每一个处理器的使用情况，常见用法如下：
mpstat -P ALL interval times

8）netstat
用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况
常用方法：netstat -npl 上面这条命令可以查看你要打开的端口是否已经打开，以此来作为程序是否已经启动的依据

netstat -rn 打印路由表，其中 flag域的解释如下：
U 该路由可用
G 该路由是到一个到网关（路由器）。如果没有设置该标志，说明目的地址是直接相连的
H 该路由是到一个主机
D 该路由是由重定向报文创建
M 该路由已被重定向报文修改

netstat -in 系统上的接口信息，打印每个接口的MTU，输入分组数，输入错误，输出分组数，输出错误，冲突以及当前的输出队列的长度

9）ps
最常用用法：ps -ef
杀掉僵尸进程：ps -eal | awk '{ if ($2 == "Z" ){ print $4}}' | xargs kill -9

10）strace

11）lsof
一个列出当前系统打开文件的工具，常见的用法：
查看文件系统阻塞 lsof /boot
查看端口号被哪个进程占用 lsof -i :3306
查看用户打开哪些文件 lsof -u username
查看进程打开哪些文件 lsof -p 4838
查看远程已打开的网络链接 lsof -i @192.168.34.128











