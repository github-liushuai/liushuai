#linux性能分析工具
1）vmstat
对系统级的整体情况进行统计，不足之处是无法对某个进程进行深入分析
用法：vmstat interval [times]，即每隔interval秒采样一次，共采样times次，如果省略times，则一直采集数据到用户手动停止
#vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 46839104 2596188 145670048    0    0    47    91    0    0  0  1 99  0  0
 0  0      0 46838628 2596196 145670064    0    0     0    30 1028 1659  0  0 100  0  0
 0  0      0 46838992 2596204 145670064    0    0     0    20 1050 1713  0  0 100  0  0
 0  0      0 46839092 2596212 145670064    0    0     0    16 1288 1991  0  0 100  0  0
 ...
 
 第一行的值是显示了自系统启动以来的平均值，第二行开始展示现在正在发生的情况，接下来的行会显示每5秒的间隔内发生了什么，每一列的含义在头部，如下所示：
 procs：
 r -- 多少进程正在等待cpu -- 展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈
 b -- 多少进程正在不可中断的休眠（通常意味着它们在等待IO ，例如磁盘，网络，用户输入，等等）
 
 memory：
 swpd -- 正在使用虚拟的内存大小，单位k
 free -- 空闲内存大小
 buff -- 已用的buff大小，对块设备的读写进行缓冲
 cache -- 已用的cache大小，文件系统的cache
 inact -- 非活跃内存大小，即被标明可回收的内存，区别于free和active（当使用-a选项时显示）
 active -- 活跃的内存大小（当使用-a选项时显示）
 
 swap：
 si -- 每秒从交换区写入内存的大小（单位：kb/s） -- 如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉
 so -- 每秒从内存写到交换区的大小 -- 同上
 
 io：
 bi -- 每秒读取的块数（读磁盘）
 bo -- 每秒写入的块数（写磁盘）
 
 system：这两个值越大，会看到由内核消耗的cpu时间会越多
 in -- 每秒中断数，包括时钟中断
 cs -- 每秒上下文切换数
 
 cpu:
 us -- 用户进程执行消耗cpu时间(user time) -- us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了
 sy -- 系统进程消耗cpu时间(system time) -- sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因
 id -- 空闲时间(包括IO等待时间)
 wa -- 等待IO时间 -- Wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈
 st -- 虚拟机偷取时间 -- 是专门对虚拟机来说的，一台物理是可以虚拟化出几台虚拟机的，在其中一台虚拟机上用top查看发现st不为0，就说明本来有这么多个cpu时间是安排给我这个虚拟机的，但是由于某种虚拟技术，把这个cpu时间分配给了其他的虚拟机了

2）iostat
对系统级的I/O情况进行分析，不足之处是无法对某个进程进行深入分析
用法：iostat -dx interval [times]，默认情况下，它显示了与vmstat 相同的CPU使用信息，使用dx参数可仅输出I/O相关的数据，每隔interval秒采样一次，共采样times次
#iostat -dx 3
Linux 3.10.0-327.ali2018.alios7.x86_64 (OceanBase166085097.sqa.eu95) 	01/19/2020 	_x86_64_	(24 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.01   186.87   19.36   16.22   723.09   967.64    95.03     0.03    0.83    0.14    1.65   1.07   3.82
sdb               0.00   284.49    4.07    9.25   385.71  1175.23   234.50     0.08    6.20    0.13    8.87   4.32   5.75
nb0               0.00     0.00    0.00    0.00     0.00     0.00     8.37     0.00    0.38    0.35    3.57   0.03   0.00

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.00     5.67    0.00    7.67     0.00    56.00    14.61     0.00    0.09    0.00    0.09   0.09   0.07
sdb               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00
nb0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               0.00     0.00    0.00    3.00     0.00    14.67     9.78     0.00    0.00    0.00    0.00   0.00   0.00
sdb               0.00     3.67    0.00    0.67     0.00    17.33    52.00     0.00    0.00    0.00    0.00   0.00   0.00
nb0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00    0.00    0.00   0.00   0.00
...

为了看懂Linux的磁盘IO指标，先了解一些常见的缩写习惯：
rq -- request
r -- read
w -- write
qu -- queue（队列）
sz -- size
a -- average（平均）
tm -- time
svc -- service

下面讲解具体项的含义（第一次采样信息与单独执行iostat的效果一样，为从系统开机到当前执行时刻的统计信息）：
rrqm/s 和 wrqm/s -- 每秒合并的读和写请求，"合并的"意味着文件系统会对读取同块(block)的请求进行合并
r/s 和 w/s -- 每秒发送到设备的读和写请求数
rkB/s 和 wkB/s -- 每秒 读/写 数据量(kB为单位)
avgrq-sz -- 平均每次IO操作的数据量(扇区数为单位)
avgqu-sz -- 平均等待处理的IO请求队列长度
await -- 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)
svctm -- 平均每次IO请求的处理时间(毫秒为单位)
%util -- 采用周期内用于IO操作的时间比率，即IO队列非空的时间比率

IO瓶颈的症状： 1.%util 很高  2.await 远大于svctm  3.avgqu-sz 比较大

结合vmstat和iostat两个命令，可以查看到以下类型机器的输出分别有以下特点
cpu 密集型机器：
vmstat 输出通常在us列（用户进程消耗cpu时间）会有一个很高的值，也可能在sy列（系统进程消耗cpu时间）有很高的值，超过20%就足以令人不安了，在大部分情况下，也会有进程队列排队时间（在r列报告的）
iostat 的输出（剔除显示启动以来平均值的第一行），可以发现磁盘利用率低于50%

IO 密集型机器：
在IO密集型工作负载下，CPU花费大量时间在等待IO请求完成。这意味着vmstat 会显示很多处理器在非中断休眠(b列)状态，并且在wa（等待IO时间）这一列的值很高
iostat 输出显示硬盘一直很忙
只要有足够的缓冲来服务写请求，即使机器正在做大量的写操作，也可能可以满足，但是却通常意味着硬盘可能会无法满足读请求，因为写有缓冲而读没有

发生内存交换的机器：
swpd 列可能有一个很高的值，也可能不高。但是可以看到si 和 so 列有很高的值

空闲的机器：
idle列显示CPU是接近100%的空闲






