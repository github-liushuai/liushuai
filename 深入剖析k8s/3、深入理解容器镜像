Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知，这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变
而在此之前，新创建的容器会直接继承宿主机的各个挂载点，所以光有Mount Namespace还是不够的，这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效
方案：镜像（rootfs根文件系统）+ pivot_root系统调用 或 chroot

现在，你应该可以理解，对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：
  1. 启用 Linux Namespace 配置；
  2. 设置指定的 Cgroups 参数；
  3. 切换进程的根目录（Change Root）
需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核
在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像  

正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：一致性
由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起
对一个应用来说，操作系统本身才是它运行所需要的最完整的“依赖库”

docker镜像主要技术实现：联合文件系统Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下

容器的rootfs主要由三部分构成：
  可读写层（rw）：容器的任何修改操作，都会以增量的方式出现在这个层中
  init层（ro+wh）：单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息，这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉
  只读层（ro+wh）：即镜像
wh的含义：whiteout，如果要删除一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件，这样当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了  

既然容器的 rootfs是以只读方式挂载的，那么又如何在容器里修改镜像的内容呢？
答：写时复制，在需要修改的时候，把要修改的那个文件复制到读写层，再进行修改
