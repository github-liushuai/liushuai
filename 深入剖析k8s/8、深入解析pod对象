凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的，这些属性的共同特征是，它们描述的是“机器”这个整体，而不是里面运行的“程序
此外，凡是跟容器的 Linux Namespace相关的属性，也一定是 Pod 级别的

接下来介绍 Pod 中几个重要字段的含义和用法：
  1、NodeSelector：是一个供用户将 Pod 与 Node 进行绑定的字段
  """
  apiVersion: v1
  kind: Pod
  ...
  spec: 
    nodeSelector:   
      disktype: ssd
  """
  意味着这个 Pod 永远只能运行在携带了“disktype: ssd”标签（Label）的节点上；否则，它将调度失败
  
  2、NodeName：一旦 Pod 的这个字段被赋值，Kubernetes 项目就会被认为这个 Pod 已经经过了调度，调度的结果就是赋值的节点名字，这个字段一般由调度器负责设置，但用户也可以设置它来“骗过”调度器
  3、HostAliases：定义了 Pod 的 hosts 文件（比如 /etc/hosts）里的内容
  
  """
  apiVersion: v1
  kind: Pod
  metadata:  
    name: nginx
  spec:  
    shareProcessNamespace: true  
    containers:  
    - name: nginx    
      image: nginx  
    - name: shell    
      image: busybox    
      stdin: true    
      tty: true
  """
  4、在这个YAML文件中定义了shareProcessNamespace=true，意味着这个 Pod 里的容器要共享 PID Namespace
  此外还定义了一个开启 tty 和stdin 的 shell 容器，同于设置了 docker run 里的 -it（-i 即 stdin，-t 即 tty）参数，在 shell 容器里执行 ps 指令不仅可以看到它本身的进程，还可以看到 nginx 容器的进程，以及 pause 容器的 /pause 进程
  这就意味着，整个 Pod 里的每个容器的进程，对于所有容器来说都是可见的：它们共享了同一个 PID Namespace
  
  5、Container 字段中有这么几个属性值需要额外关注
    1）ImagePullPolicy：镜像拉取策略
    2）Lifecycle：Container Lifecycle Hooks，作用是在容器状态发生变化时触发一系列“钩子”，我们来看这样一个例子：
      """
      ...
      spec:  
        containers:  
        - name: lifecycle-demo-container    
          image: nginx
          lifecycle:      
            postStart:        
              exec:          
                command: ["/bin/sh", "-c", "echo Hello from the postStart handler > /usr/share/message"]      
            preStop:        
              exec:          
                command: ["/usr/sbin/nginx","-s","quit"]
        """
        postStart 指的是在容器启动后，立刻执行一个指定的操作，需要明确的是postStart 定义的操作，虽然是在 Docker 容器 ENTRYPOINT 执行之后，但它并不严格保证顺序，也就是说在 postStart 启动时，ENTRYPOINT 有可能还没有结束
        当然，如果 postStart 执行超时或者错误，Kubernetes 会在该 Pod 的 Events 中报出该容器启动失败的错误信息，导致 Pod 也处于失败的状态
        
        preStop 发生的时机，则是容器被杀死之前（比如，收到了 SIGKILL 信号），需要明确的是，preStop 操作的执行，是同步的。所以，它会阻塞当前的容器杀死流程，直到这个 Hook 定义操作完成之后，才允许容器被杀死，这跟 postStart 不一样
        

Pod 对象在 Kubernetes 中的生命周期（主要体现在 Pod API 对象的Status 部分，这是它除了 Metadata和 Spec 之外的第三个重要字段，其中pod.status.phase就是 Pod 的当前状态）：
  1. Pending。这个状态意味着，Pod 的 YAML 文件已经提交给了 Kubernetes，API 对象已经被创建并保存在 Etcd 当中。但是，这个 Pod 里有些容器因为某种原因而不能被顺利创建。比如，调度不成功。
  2. Running。这个状态下，Pod 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行中。
  3. Succeeded。这个状态意味着，Pod 里的所有容器都正常运行完毕，并且已经退出了。这种情况在运行一次性任务时最为常见。
  4. Failed。这个状态下，Pod 里至少有一个容器以不正常的状态（非 0 的返回码）退出。这个状态的出现，意味着你得想办法 Debug 这个容器的应用，比如查看 Pod 的 Events和日志。
  5. Unknown。这是一个异常状态，意味着 Pod 的状态不能持续地被 kubelet 汇报给kube-apiserver，这很有可能是主从节点（Master 和 Kubelet）间的通信出现了问题
Pod 对象的 Status 字段，还可以再细分出一组 Conditions。这些细分状态的值包括：PodScheduled、Ready、Initialized，以及 Unschedulable。它们主要用于描述造成当前 Status 的具体原因是什么
比如，Pod 当前的 Status 是 Pending，对应的 Condition 是 Unschedulable，这就意味着它的调度出现了问题
而其中，Ready 这个细分状态非常值得我们关注：它意味着 Pod 不仅已经正常启动（Running 状态），而且已经可以对外提供服务了。这两者之间（Running 和 Ready）是有区别的
  
  
  

