声明式API的特点：
  1、我只需要提交一个定义好的 API 对象来“声明”，我所期望的状态是什么样子
  2、许有多个 API 写端，以 PATCH 的方式对 API 对象进行修改，而无需关心本地原始 YAML 文件的内容，一次能处理多个写操作，并且具备 Merge 能力
  有了上述两个能力，Kubernetes 项目才可以基于对 API 对象的增、删、改、查，在完全无需外界干预的情况下，完成对“实际状态”和“期望状态”的调谐（Reconcile）过程

接下来以lstio（一个基于 Kubernetes 项目的微服务治理框架）为例来说明声明式 API 在实际使用时的重要意义
Istio 最根本的组件，是运行在每一个应用 Pod 里的 Envoy 容器，以 sidecar 容器的方式运行在了每一个被治理的应用Pod 中，且共享同一个 Network Namespace，所以Envoy 容器就能够通过配置 Pod 里的 iptables 规则，把整个 Pod 的进出流量接管下来；
Istio 的控制层（Control Plane）里的 Pilot 组件，就能够通过调用每个 Envoy容器的 API，对这个 Envoy 代理进行配置，从而实现微服务治理；
更重要的是，在整个微服务治理的过程中，无论是对 Envoy 容器的部署，还是像上面这样对 Envoy 代理的配置，用户和应用都是完全“无感”的！
举个例子，假如有两个Pod分别是新版本和旧版本的应用，Pilot 可以通过调节这两 Pod 里的 Envoy 容器的配置，从而将 90%的流量分配给旧版本的应用，将 10% 的流量分配给新版本应用，并且还可以在后续的过程中随时调整，直至所有流量全部分配给新版本，这就完成了这个灰度发布的过程

明明需要往Pod里面注入Envoy容器，lstio又是怎么做到用户和应用对此都是完全“无感”的呢？
答：Istio 项目使用的，是 Kubernetes 中的一个非常重要的功能，叫作 DynamicAdmission Control
   我们先来介绍一下Admission Control：任何一个 API 对象被提交给 APIServer 之后，总有一些“初始化”性质的工作需要在它们被 Kubernetes 项目正式处理之前进行，
   比如，自动为所有 Pod 加上某些标签（Labels），而这个“初始化”操作的实现就是借助Admission Control，它可以选择性地被编译进APIServer 中，在 API 对象创建之后会被立刻调用到；
   我们无法使用 Admission Controller来添加自己的规则，因为这意味着要重新编译和重启APIServer；
   所以，Kubernetes 项目为我们额外提供了一种“热插拔”式的 Admission 机制，它就是Dynamic Admission Control，也叫作：Initializer

Istio 项目要做的，就是在这个 Pod YAML 被提交给 Kubernetes 之后，在它对应的 API 对象里自动加上 Envoy 容器的配置



